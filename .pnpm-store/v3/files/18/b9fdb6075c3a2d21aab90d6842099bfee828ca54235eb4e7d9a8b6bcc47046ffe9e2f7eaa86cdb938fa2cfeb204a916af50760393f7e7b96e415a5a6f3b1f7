import { normalizeIndex } from "@ark/schema";
import { append, escapeToken, printable, stringAndSymbolicEntriesOf, throwParseError } from "@ark/util";
export const parseObjectLiteral = (def, ctx) => {
    let spread;
    const structure = {};
    // We only allow a spread operator to be used as the first key in an object
    // because to match JS behavior any keys before the spread are overwritten
    // by the values in the target object, so there'd be no useful purpose in having it
    // anywhere except for the beginning.
    const parsedEntries = stringAndSymbolicEntriesOf(def).flatMap(entry => parseEntry(entry[0], entry[1], ctx));
    if (parsedEntries[0]?.kind === "spread") {
        // remove the spread entry so we can iterate over the remaining entries
        // expecting non-spread entries
        const spreadEntry = parsedEntries.shift();
        if (!spreadEntry.node.hasKind("intersection") ||
            !spreadEntry.node.structure) {
            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.node.expression));
        }
        spread = spreadEntry.node.structure;
    }
    for (const entry of parsedEntries) {
        if (entry.kind === "spread")
            return throwParseError(nonLeadingSpreadError);
        if (entry.kind === "undeclared") {
            structure.undeclared = entry.behavior;
            continue;
        }
        structure[entry.kind] = append(structure[entry.kind], entry);
    }
    const structureNode = ctx.$.node("structure", structure);
    return ctx.$.parseSchema({
        domain: "object",
        structure: spread?.merge(structureNode) ?? structureNode
    });
};
export const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;
export const nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
export const parseEntry = (key, value, ctx) => {
    const parsedKey = parseKey(key);
    if (parsedKey.kind === "+") {
        if (value !== "reject" && value !== "delete" && value !== "ignore")
            throwParseError(writeInvalidUndeclaredBehaviorMessage(value));
        return { kind: "undeclared", behavior: value };
    }
    if (parsedKey.kind === "...")
        return { kind: "spread", node: ctx.$.parseOwnDefinitionFormat(value, ctx) };
    const parsedValue = ctx.$.parseOwnDefinitionFormat(value, ctx);
    if (parsedKey.kind === "index") {
        const signature = ctx.$.parseOwnDefinitionFormat(parsedKey.key, ctx);
        const normalized = normalizeIndex(signature, parsedValue, ctx.$);
        return (normalized.index ?
            normalized.required ?
                [normalized.index, ...normalized.required]
                : normalized.index
            : (normalized.required ?? []));
    }
    if (parsedValue.meta) {
        if ("default" in parsedValue.meta) {
            return ctx.$.node("optional", {
                key: parsedKey.key,
                value: parsedValue,
                default: parsedValue.meta.default
            });
        }
        if (parsedValue.meta.optional) {
            return ctx.$.node("optional", {
                key: parsedKey.key,
                value: parsedValue
            });
        }
    }
    return ctx.$.node(parsedKey.kind, {
        key: parsedKey.key,
        value: parsedValue
    });
};
const parseKey = (key) => typeof key === "symbol" ? { kind: "required", key }
    : key.at(-1) === "?" ?
        key.at(-2) === escapeToken ?
            { kind: "required", key: `${key.slice(0, -2)}?` }
            : {
                kind: "optional",
                key: key.slice(0, -1)
            }
        : key[0] === "[" && key.at(-1) === "]" ?
            { kind: "index", key: key.slice(1, -1) }
            : key[0] === escapeToken && key[1] === "[" && key.at(-1) === "]" ?
                { kind: "required", key: key.slice(1) }
                : key === "..." ? { kind: key, key }
                    : key === "+" ? { kind: key, key }
                        : {
                            kind: "required",
                            key: key === "\\..." ? "..."
                                : key === "\\+" ? "+"
                                    : key
                        };
export const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;
