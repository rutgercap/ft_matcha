import { ArkErrors, BaseRoot, type BaseParseOptions, type MetaSchema, type Morph, type Predicate, type RootSchema } from "@ark/schema";
import { Callable, Hkt, type Constructor, type array, type conform } from "@ark/util";
import type { Generic, GenericParser, ParameterString, baseGenericConstraints, parseValidGenericParams, validateParameterString } from "./generic.ts";
import type { Ark, ark, type } from "./keywords/ark.ts";
import type { distill } from "./keywords/ast.ts";
import type { BaseType } from "./methods/base.ts";
import type { instantiateType } from "./methods/instantiate.ts";
import type { validateDeclared, validateDefinition } from "./parser/definition.ts";
import type { IndexOneOperator, IndexZeroOperator, TupleInfixOperator } from "./parser/tuple.ts";
import type { InternalScope, ModuleParser, Scope, ScopeParser, bindThis } from "./scope.ts";
/** The convenience properties attached to `type` */
export type TypeParserAttachments = Omit<TypeParser, never>;
export interface TypeParser<$ = {}> extends Ark.boundTypeAttachments<$> {
    <const def, r = Type<type.infer<def, $>, $>>(def: type.validate<def, $>): r;
    <const params extends ParameterString, const def>(params: validateParameterString<params, $>, def: validateDefinition<def, $, baseGenericConstraints<parseValidGenericParams<params, $>>>): Generic<parseValidGenericParams<params, $>, def, $>;
    <const zero, const one, const rest extends array, r = Type<type.infer<[zero, one, ...rest], $>, $>>(_0: zero extends IndexZeroOperator ? zero : type.validate<zero, $>, _1: zero extends "keyof" ? type.validate<one, $> : zero extends "instanceof" ? conform<one, Constructor> : zero extends "===" ? conform<one, unknown> : conform<one, IndexOneOperator>, ..._2: zero extends "===" ? rest : zero extends "instanceof" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends ":" ? [Predicate<distill.In<type.infer<zero, $>>>] : one extends "=>" ? [Morph<distill.Out<type.infer<zero, $>>, unknown>] : one extends "@" ? [MetaSchema] : [type.validate<rest[0], $>] : []): r;
    $: Scope<$>;
    raw(def: unknown): BaseType<any, $>;
    errors: typeof ArkErrors;
    hkt: typeof Hkt;
    ark: typeof ark;
    module: ModuleParser;
    scope: ScopeParser;
    define: DefinitionParser<$>;
    generic: GenericParser<$>;
    schema: SchemaParser<$>;
    unit: UnitTypeParser<$>;
    enumerated: EnumeratedTypeParser<$>;
}
export declare class InternalTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {
    constructor($: InternalScope);
}
export type DeclarationParser<$> = <preinferred>() => {
    type: <const def>(def: validateDeclared<preinferred, def, $, bindThis<def>>) => Type<preinferred, $>;
};
export type UnitTypeParser<$> = <const t>(value: t) => Type<t, $>;
export type EnumeratedTypeParser<$> = <const values extends readonly unknown[]>(...values: values) => Type<values[number], $>;
export type DefinitionParser<$> = <const def>(def: type.validate<def, $>) => def;
export type SchemaParser<$> = (schema: RootSchema, opts?: BaseParseOptions) => Type<unknown, $>;
export type Type<t = unknown, $ = {}> = instantiateType<t, $>;
export type TypeConstructor<t = unknown, $ = {}> = new (def: unknown, $: Scope<$>) => Type<t, $>;
export declare const Type: TypeConstructor;
