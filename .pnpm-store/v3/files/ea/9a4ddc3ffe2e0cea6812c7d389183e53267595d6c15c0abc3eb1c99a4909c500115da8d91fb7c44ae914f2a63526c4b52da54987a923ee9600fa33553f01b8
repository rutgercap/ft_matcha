import { $ark, BaseScope, hasArkKind, parseGeneric } from "@ark/schema";
import { domainOf, flatMorph, hasDomain, isThunk, throwParseError } from "@ark/util";
import { parseGenericParamName } from "./generic.js";
import { parseObject, writeBadDefinitionTypeMessage } from "./parser/definition.js";
import { DynamicState } from "./parser/string/reduce/dynamic.js";
import { writeUnexpectedCharacterMessage } from "./parser/string/shift/operator/operator.js";
import { Scanner } from "./parser/string/shift/scanner.js";
import { fullStringParse } from "./parser/string/string.js";
import { InternalTypeParser } from "./type.js";
export const $arkTypeRegistry = $ark;
export class InternalScope extends BaseScope {
    parseCache = {};
    cacheGetter(name, value) {
        Object.defineProperty(this, name, { value });
        return value;
    }
    get ambientAttachments() {
        if (!$arkTypeRegistry.typeAttachments)
            return;
        return this.cacheGetter("ambientAttachments", flatMorph($arkTypeRegistry.typeAttachments, (k, v) => [
            k,
            this.bindReference(v)
        ]));
    }
    preparseOwnAliasEntry(k, v) {
        const firstParamIndex = k.indexOf("<");
        if (firstParamIndex === -1)
            return [k, v];
        if (k.at(-1) !== ">") {
            throwParseError(`'>' must be the last character of a generic declaration in a scope`);
        }
        const name = k.slice(0, firstParamIndex);
        const paramString = k.slice(firstParamIndex + 1, -1);
        return [
            name,
            // use a thunk definition for the generic so that we can parse
            // constraints within the current scope
            () => {
                const params = this.parseGenericParams(paramString, { alias: name });
                const generic = parseGeneric(params, v, this);
                return generic;
            }
        ];
    }
    parseGenericParams(def, opts) {
        return parseGenericParamName(new Scanner(def), [], this.createParseContext({ ...opts, def, prefix: "generic" }));
    }
    normalizeRootScopeValue(resolution) {
        if (isThunk(resolution) && !hasArkKind(resolution, "generic"))
            return resolution();
        return resolution;
    }
    preparseOwnDefinitionFormat(def, opts) {
        return {
            ...opts,
            def,
            prefix: opts.alias ?? "type"
        };
    }
    parseOwnDefinitionFormat(def, ctx) {
        const isScopeAlias = ctx.alias && ctx.alias in this.aliases;
        // if the definition being parsed is not a scope alias and is not a
        // generic instantiation (i.e. opts don't include args), add this as a resolution.
        if (!isScopeAlias && !ctx.args)
            ctx.args = { this: ctx.id };
        if (typeof def === "string") {
            if (ctx.args && Object.keys(ctx.args).some(k => def.includes(k))) {
                // we can only rely on the cache if there are no contextual
                // resolutions like "this" or generic args
                return this.parseString(def, ctx);
            }
            return (this.parseCache[def] ??= this.parseString(def, ctx));
        }
        return hasDomain(def, "object") ?
            parseObject(def, ctx)
            : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));
    }
    parseString(def, ctx) {
        const aliasResolution = this.maybeResolveRoot(def);
        if (aliasResolution)
            return aliasResolution;
        const aliasArrayResolution = def.endsWith("[]") ?
            this.maybeResolveRoot(def.slice(0, -2))?.array()
            : undefined;
        if (aliasArrayResolution)
            return aliasArrayResolution;
        const s = new DynamicState(new Scanner(def), ctx);
        const node = fullStringParse(s);
        if (s.finalizer === ">")
            throwParseError(writeUnexpectedCharacterMessage(">"));
        return node;
    }
    unit = value => this.units([value]);
    enumerated = (...values) => this.units(values);
    type = new InternalTypeParser(this);
    declare = () => ({
        type: this.type
    });
    define = ((def) => def).bind(this);
    static scope = ((def, config = {}) => new InternalScope(def, config));
    static module = ((def, config = {}) => this.scope(def, config).export());
}
export const scope = InternalScope.scope;
export const module = InternalScope.module;
export const Scope = InternalScope;
