import type { BaseParseContext, BaseRoot } from "@ark/schema";
import { type requireKeys } from "@ark/util";
import type { LimitLiteral } from "../../../keywords/ast.ts";
import type { InfixOperator } from "../../semantic/infer.ts";
import type { Scanner } from "../shift/scanner.ts";
import { type Comparator, type MinComparator, type OpenLeftBound, type StringifiablePrefixOperator } from "./shared.ts";
type BranchState = {
    prefixes: StringifiablePrefixOperator[];
    leftBound: OpenLeftBound | null;
    intersection: BaseRoot | null;
    union: BaseRoot | null;
};
export type DynamicStateWithRoot = requireKeys<DynamicState, "root">;
export declare class DynamicState {
    root: BaseRoot<any> | undefined;
    branches: BranchState;
    finalizer: Scanner.FinalizingLookahead | undefined;
    groups: BranchState[];
    scanner: Scanner;
    ctx: BaseParseContext;
    constructor(scanner: Scanner, ctx: BaseParseContext);
    error(message: string): never;
    hasRoot(): this is DynamicStateWithRoot;
    setRoot(root: BaseRoot): void;
    unsetRoot(): this["root"];
    constrainRoot(...args: Parameters<BaseRoot<any>["constrain"]>): void;
    finalize(finalizer: Scanner.FinalizingLookahead): void;
    reduceLeftBound(limit: LimitLiteral, comparator: Comparator): void;
    finalizeBranches(): void;
    finalizeGroup(): void;
    addPrefix(prefix: StringifiablePrefixOperator): void;
    applyPrefixes(): void;
    pushRootToBranch(token: "|" | "&"): void;
    parseUntilFinalizer(): DynamicStateWithRoot;
    parseOperator(this: DynamicStateWithRoot): void;
    parseOperand(): void;
    private assertRangeUnset;
    reduceGroupOpen(): void;
    previousOperator(): MinComparator | StringifiablePrefixOperator | InfixOperator | undefined;
    shiftedByOne(): this;
}
export {};
