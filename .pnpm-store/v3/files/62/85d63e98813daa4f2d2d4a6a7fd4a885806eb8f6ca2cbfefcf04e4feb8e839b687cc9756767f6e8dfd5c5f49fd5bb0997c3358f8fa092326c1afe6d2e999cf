import { type array, type Key, type listable } from "@ark/util";
import { BaseConstraint } from "../constraint.ts";
import type { GettableKeyOrNode, KeyOrKeyNode } from "../node.ts";
import { type BaseRoot } from "../roots/root.ts";
import type { BaseScope } from "../scope.ts";
import type { NodeCompiler } from "../shared/compile.ts";
import type { BaseNormalizedSchema, declareNode } from "../shared/declare.ts";
import { type nodeImplementationOf, type StructuralKind } from "../shared/implement.ts";
import { type JsonSchema } from "../shared/jsonSchema.ts";
import { type RegisteredReference } from "../shared/registry.ts";
import type { TraversalContext, TraversalKind, TraverseAllows, TraverseApply } from "../shared/traversal.ts";
import { makeRootAndArrayPropertiesMutable } from "../shared/utils.ts";
import type { Index } from "./index.ts";
import type { Optional } from "./optional.ts";
import type { Prop } from "./prop.ts";
import type { Required } from "./required.ts";
import type { Sequence } from "./sequence.ts";
export type UndeclaredKeyBehavior = "ignore" | UndeclaredKeyHandling;
export type UndeclaredKeyHandling = "reject" | "delete";
export declare namespace Structure {
    interface Schema extends BaseNormalizedSchema {
        readonly optional?: readonly Optional.Schema[];
        readonly required?: readonly Required.Schema[];
        readonly index?: readonly Index.Schema[];
        readonly sequence?: Sequence.Schema;
        readonly undeclared?: UndeclaredKeyBehavior;
    }
    interface Inner {
        readonly optional?: readonly Optional.Node[];
        readonly required?: readonly Required.Node[];
        readonly index?: readonly Index.Node[];
        readonly sequence?: Sequence.Node;
        readonly undeclared?: UndeclaredKeyHandling;
    }
    namespace Inner {
        type mutable = makeRootAndArrayPropertiesMutable<Inner>;
    }
    interface Declaration extends declareNode<{
        kind: "structure";
        schema: Schema;
        normalizedSchema: Schema;
        inner: Inner;
        prerequisite: object;
        childKind: StructuralKind;
    }> {
    }
    type Node = StructureNode;
}
export declare class StructureNode extends BaseConstraint<Structure.Declaration> {
    impliedBasis: BaseRoot;
    impliedSiblings: BaseConstraint<import("../constraint.ts").Constraint.Declaration>[];
    props: array<Prop.Node>;
    propsByKey: Record<Key, Prop.Node | undefined>;
    propsByKeyReference: RegisteredReference;
    expression: string;
    requiredLiteralKeys: Key[];
    optionalLiteralKeys: Key[];
    literalKeys: Key[];
    entries: array<NodeEntry>;
    _keyof: BaseRoot | undefined;
    keyof(): BaseRoot;
    map(flatMapEntry: NodeEntryFlatMapper): StructureNode;
    assertHasKeys(keys: array<KeyOrKeyNode>): void;
    get(indexer: GettableKeyOrNode, ...path: array<GettableKeyOrNode>): BaseRoot;
    readonly exhaustive: boolean;
    pick(...keys: KeyOrKeyNode[]): StructureNode;
    omit(...keys: KeyOrKeyNode[]): StructureNode;
    optionalize(): StructureNode;
    require(): StructureNode;
    merge(r: StructureNode): StructureNode;
    private filterKeys;
    traverseAllows: TraverseAllows<object>;
    traverseApply: TraverseApply<object>;
    protected _traverse: (traversalKind: TraversalKind, data: object, ctx: TraversalContext) => boolean;
    compile(js: NodeCompiler): void;
    protected compileExhaustiveEntry(js: NodeCompiler): NodeCompiler;
    reduceJsonSchema(schema: JsonSchema.Structure): JsonSchema.Structure;
    reduceObjectJsonSchema(schema: JsonSchema.Object): JsonSchema.Object;
}
export type NodeEntryFlatMapper = (entry: NodeEntry) => listable<MappedNodeEntry>;
export type NodeEntry = readonly [
    key: Key,
    value: BaseRoot,
    kind: "required" | "optional"
];
export type MappedNodeEntry = readonly [
    key: Key,
    value: BaseRoot,
    kind?: "required" | "optional"
];
export declare const Structure: {
    implementation: nodeImplementationOf<Structure.Declaration>;
    Node: typeof StructureNode;
};
export declare const writeNumberIndexMessage: (indexExpression: string, sequenceExpression: string) => string;
export type NormalizedIndex = {
    index?: Index.Node;
    required?: Required.Node[];
};
/** extract enumerable named props from an index signature */
export declare const normalizeIndex: (signature: BaseRoot, value: BaseRoot, $: BaseScope) => NormalizedIndex;
export declare const typeKeyToString: (k: KeyOrKeyNode) => string;
export declare const writeInvalidKeysMessage: <o extends string, keys extends array<KeyOrKeyNode>>(o: o, keys: keys) => string;
