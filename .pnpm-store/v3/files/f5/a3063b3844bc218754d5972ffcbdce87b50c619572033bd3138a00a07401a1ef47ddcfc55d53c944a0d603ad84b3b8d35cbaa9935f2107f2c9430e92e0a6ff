import { arrayEquals, liftArray, throwParseError } from "@ark/util";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodes } from "../shared/intersections.js";
import { writeJsonSchemaMorphMessage } from "../shared/jsonSchema.js";
import { $ark, registeredReference } from "../shared/registry.js";
import { hasArkKind } from "../shared/utils.js";
import { BaseRoot } from "./root.js";
import { defineRightwardIntersections } from "./utils.js";
const implementation = implementNode({
    kind: "morph",
    hasAssociatedError: false,
    keys: {
        in: {
            child: true,
            parse: (schema, ctx) => ctx.$.parseSchema(schema)
        },
        morphs: {
            parse: liftArray,
            serialize: morphs => morphs.map(m => hasArkKind(m, "root") ? m.json : registeredReference(m))
        },
        declaredIn: {
            child: false,
            serialize: node => node.json
        },
        declaredOut: {
            child: false,
            serialize: node => node.json
        }
    },
    normalize: schema => schema,
    defaults: {
        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? "unknown"}`
    },
    intersections: {
        morph: (l, r, ctx) => {
            if (!l.hasEqualMorphs(r)) {
                return throwParseError(writeMorphIntersectionMessage(l.expression, r.expression));
            }
            const inTersection = intersectNodes(l.in, r.in, ctx);
            if (inTersection instanceof Disjoint)
                return inTersection;
            const baseInner = {
                morphs: l.morphs
            };
            if (l.declaredIn || r.declaredIn) {
                const declaredIn = intersectNodes(l.in, r.in, ctx);
                // we can't treat this as a normal Disjoint since it's just declared
                // it should only happen if someone's essentially trying to create a broken type
                if (declaredIn instanceof Disjoint)
                    return declaredIn.throw();
                else
                    baseInner.declaredIn = declaredIn;
            }
            if (l.declaredOut || r.declaredOut) {
                const declaredOut = intersectNodes(l.out, r.out, ctx);
                if (declaredOut instanceof Disjoint)
                    return declaredOut.throw();
                else
                    baseInner.declaredOut = declaredOut;
            }
            // in case from is a union, we need to distribute the branches
            // to can be a union as any schema is allowed
            return inTersection.distribute(inBranch => ctx.$.node("morph", {
                ...baseInner,
                in: inBranch
            }), ctx.$.parseSchema);
        },
        ...defineRightwardIntersections("morph", (l, r, ctx) => {
            const inTersection = intersectNodes(l.in, r, ctx);
            return inTersection instanceof Disjoint ? inTersection : (inTersection.distribute(branch => ({
                ...l.inner,
                in: branch
            }), ctx.$.parseSchema));
        })
    }
});
export class MorphNode extends BaseRoot {
    serializedMorphs = this.morphs.map(registeredReference);
    compiledMorphs = `[${this.serializedMorphs}]`;
    lastMorph = this.inner.morphs.at(-1);
    validatedIn = this.inner.in;
    validatedOut = hasArkKind(this.lastMorph, "root") ?
        Object.assign(this.referencesById, this.lastMorph.out.referencesById) &&
            this.lastMorph.out
        : undefined;
    get in() {
        return this.declaredIn ?? this.inner.in ?? $ark.intrinsic.unknown.internal;
    }
    get out() {
        return (this.declaredOut ?? this.validatedOut ?? $ark.intrinsic.unknown.internal);
    }
    declareIn(declaredIn) {
        return this.$.node("morph", {
            ...this.inner,
            declaredIn
        });
    }
    declareOut(declaredOut) {
        return this.$.node("morph", {
            ...this.inner,
            declaredOut
        });
    }
    expression = `(In: ${this.in.expression}) => Out<${this.out.expression}>`;
    get shortDescription() {
        return this.in.shortDescription;
    }
    innerToJsonSchema() {
        return throwParseError(writeJsonSchemaMorphMessage(this.expression));
    }
    compile(js) {
        if (js.traversalKind === "Allows") {
            if (!this.validatedIn)
                return;
            js.return(js.invoke(this.validatedIn));
            return;
        }
        if (this.validatedIn)
            js.line(js.invoke(this.validatedIn));
        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
    }
    traverseAllows = (data, ctx) => !this.validatedIn || this.validatedIn.traverseAllows(data, ctx);
    traverseApply = (data, ctx) => {
        if (this.validatedIn)
            this.validatedIn.traverseApply(data, ctx);
        ctx.queueMorphs(this.morphs);
    };
    /** Check if the morphs of r are equal to those of this node */
    hasEqualMorphs(r) {
        return arrayEquals(this.morphs, r.morphs, {
            isEqual: (lMorph, rMorph) => lMorph === rMorph ||
                (hasArkKind(lMorph, "root") &&
                    hasArkKind(rMorph, "root") &&
                    lMorph.equals(rMorph))
        });
    }
}
export const Morph = {
    implementation,
    Node: MorphNode
};
export const writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;
